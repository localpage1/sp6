<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>全屏图片浏览 (IndexedDB)</title>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            height: 100%;
            overflow: hidden;
            width: 100vw;
        }

        .viewer {
            height: 100%;
            overflow-x: auto; /* 水平滚动 */
            -webkit-overflow-scrolling: touch;
            white-space: nowrap; /* 防止图片换行，使容器宽度由内容决定 */
            font-size: 0; /* 消除 inline-flex 间的空隙 */
        }

        .image-container {
            display: inline-flex; /* 水平排列 */
            margin: 0;
            padding: 0;
            height: 100%; /* 让容器高度撑满 */
        }

        .image {
            /* width: 100vw; */ /* 图片宽度由自身决定或CSS控制，不再强制100vw */
            height: 100%; /* 图片高度适应容器 */
            width: auto;  /* 宽度自适应，保持比例 */
            display: inline-block; /* 使用inline-block */
            vertical-align: top; /* 对齐方式 */
            margin: 0;
            /* transition: transform 0.1s ease-out; */ /* 通常水平滚动不需要transform */
        }

        /* 浮窗样式 */
        #scroll-position {
            position: fixed;
            /* top: 630px; */ /* 调整位置，避免写死 */
            bottom: 10px; /* 改为相对于底部 */
            left: 10px;
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 5px 10px; /* 增加一点padding */
            border-radius: 5px;
            font-size: 14px;
            z-index: 1000;
        }
    </style>
</head>
<body>
    <div class="viewer" id="viewer">
        <div class="image-container" id="image-container">
            </div>
    </div>

    <div id="scroll-position" hidden>阅读进度: 0.00%</div>

    <script>
        // === IndexedDB Image Loading Function (adapted from your example) ===
        function createImagesFromIndexedDB(container, fileNames) {
            return new Promise((resolve, reject) => { // Added reject for better error handling
                const request = indexedDB.open('SDB', 8); // Assuming same DB name and version
                let loadedCount = 0;
                const total = fileNames.length;

                if (total === 0) {
                    console.log("No filenames provided to load.");
                    resolve(); // Resolve immediately if no images to load
                    return;
                }

                request.onerror = function(event) {
                    console.error("IndexedDB error:", event.target.errorCode);
                    reject(new Error("Failed to open IndexedDB")); // Reject promise on DB open error
                };

                request.onsuccess = function(event) {
                    const db = event.target.result;
                    // Check if the object store exists
                    if (!db.objectStoreNames.contains('store')) {
                       console.error("Object store 'store' not found in IndexedDB 'SDB'.");
                       db.close(); // Close the connection
                       reject(new Error("Object store 'store' not found."));
                       return; // Stop execution
                    }

                    const transaction = db.transaction(['store'], 'readonly');
                    const store = transaction.objectStore('store');
                    let errorsOccurred = false; // Flag to track if any image failed

                    fileNames.forEach(fileName => {
                        const getReq = store.get(fileName);

                        getReq.onsuccess = function(e) {
                            const blob = e.target.result;
                            if (blob instanceof Blob) {
                                const img = new Image(); // Use new Image() for better loading control if needed
                                img.onload = () => {
                                    URL.revokeObjectURL(img.src); // Clean up object URL after load
                                    checkCompletion();
                                };
                                img.onerror = () => {
                                    console.error(`Failed to load image data for: ${fileName}`);
                                    errorsOccurred = true; // Mark error
                                    checkCompletion(); // Still need to count this attempt
                                };
                                img.src = URL.createObjectURL(blob);
                                img.alt = `Image ${fileName}`; // Use filename in alt for clarity
                                img.className = 'image';
                                container.appendChild(img);
                            } else {
                                console.warn(`File not found or not a Blob in IndexedDB: ${fileName}`);
                                checkCompletion(); // Count as processed even if not found
                            }
                        };

                        getReq.onerror = function () {
                            console.error(`Failed to read from IndexedDB: ${fileName}`);
                            errorsOccurred = true; // Mark error
                            checkCompletion(); // Count as processed
                        };
                    });

                    transaction.oncomplete = function() {
                        console.log("IndexedDB transaction complete for image loading.");
                        db.close(); // Close DB connection when transaction finishes
                        // Resolve or reject based on whether all images loaded successfully *after* checking completion
                        // Note: The promise might resolve slightly before the last img.onload fires
                        // if transaction completes first. The checkCompletion handles final resolution.
                    };

                    transaction.onerror = function(event) {
                        console.error("IndexedDB transaction error:", event.target.error);
                        db.close();
                        reject(new Error("IndexedDB transaction failed")); // Reject on transaction error
                    };

                    function checkCompletion() {
                        loadedCount++;
                        if (loadedCount === total) {
                             console.log(`Attempted to load ${total} images.`);
                            if (errorsOccurred) {
                                console.warn("Some images failed to load from IndexedDB.");
                                // Decide if partial success is acceptable or should reject
                                // resolve(); // Or reject(new Error("Some images failed"));
                                resolve(); // Resolve even with errors for this example
                            } else {
                                console.log("All images loaded successfully from IndexedDB.");
                                resolve();
                            }
                        }
                    }
                };

                 request.onupgradeneeded = function(event) {
                     // Handle DB upgrades if necessary, or log that it's happening
                     console.log("IndexedDB upgrade needed or initial setup.");
                     // Example: const db = event.target.result;
                     // if (!db.objectStoreNames.contains('store')) {
                     //     db.createObjectStore('store'); // keyPath inferred or set explicitly
                     // }
                 };
            });
        }

        // === Initialization Function ===
        async function init() {
            const viewer = document.getElementById('viewer');
            const imageContainer = document.getElementById('image-container');
            const scrollPositionDisplay = document.getElementById('scroll-position');

            // 1. Define image filenames (adjust range and prefix as needed)
            const fileNames = [];
            const prefix = 'k05';
            const start = 4;
            const end = 256;
            for (let i = start; i <= end; i++) {
                fileNames.push(`${prefix}-${i}.jpeg`); // Generate filenames
            }

            try {
                // 2. Load images asynchronously from IndexedDB
                console.log("Starting image load from IndexedDB...");
                await createImagesFromIndexedDB(imageContainer, fileNames);
                console.log("Image loading process finished.");

                 // --- Operations after images are loaded ---

                 // 3. Calculate scroll dimensions *after* images are loaded and rendered
                 // Use requestAnimationFrame to wait for layout calculation
                 requestAnimationFrame(() => {
                     const maxScroll = imageContainer.scrollWidth - viewer.offsetWidth;

                     // 4. Restore scroll position
                     let scrollPos = localStorage.getItem('scroll'); // Get saved position
                     // Default to the end (maxScroll) if nothing saved or invalid
                     let restoredScrollLeft = (scrollPos === null || isNaN(parseFloat(scrollPos))) ? maxScroll : parseFloat(scrollPos);

                     // Ensure the restored position isn't greater than the possible maximum scroll
                     restoredScrollLeft = Math.max(0, Math.min(restoredScrollLeft, maxScroll));

                     console.log(`Restoring scrollLeft to: ${restoredScrollLeft} (max: ${maxScroll})`);
                     viewer.scrollLeft = restoredScrollLeft;

                     // 5. Update scroll indicator immediately after restoring
                     updateScrollIndicator(viewer, imageContainer, scrollPositionDisplay);

                     // 6. Set up the scroll event listener *after* initial setup
                     viewer.onscroll = function() {
                         localStorage.setItem('scroll', this.scrollLeft); // Save current position
                         updateScrollIndicator(this, imageContainer, scrollPositionDisplay); // Update display
                     };
                 });

            } catch (error) {
                console.error("Initialization failed:", error);
                scrollPositionDisplay.textContent = "Error loading images";
                // Handle initialization error (e.g., show error message)
            }
        }

        // === Helper function to update scroll indicator ===
        function updateScrollIndicator(viewer, container, displayElement) {
            const scrollLeft = viewer.scrollLeft;
            const maxScroll = container.scrollWidth - viewer.offsetWidth;
            let percentage = 0;

            if (maxScroll > 0) {
                // Calculate percentage scrolled from the left
                 // percentage = (scrollLeft / maxScroll) * 100; // Percentage scrolled
                 // Or Reading Progress (100% at start, 0% at end)
                 percentage = (1 - scrollLeft / maxScroll) * 100;
            } else if (container.scrollWidth > 0) {
                 // If there's content but no scroll needed (fits entirely)
                 percentage = 100; // Or 0, depending on desired meaning
            } else {
                 // No content or zero width content
                 percentage = 0; // Or 100
            }

             // Invert for "Reading Progress" (100% at end -> 0% at start)
             // If using the reading progress calculation above (1 - ...), no need to invert here
             // percentage = 100 - percentage;


            displayElement.textContent = `阅读进度: ${percentage.toFixed(2)}%`;
        }

        // === Start the initialization process ===
        window.onload = init;

    </script>
</body>
</html>
